<script>
  const TWELVE_KEY = '26137bba624c4dcb9b5284ad1b234071';

  function cacheSet(key, obj) {
    try { localStorage.setItem(key, JSON.stringify({ ts: Date.now(), data: obj })); }
    catch {}
  }
  function cacheGet(key) {
    try { return JSON.parse(localStorage.getItem(key)); }
    catch { return null; }
  }

  function setStatus(el, type) {
    if (!el) return;
    el.classList.remove('badge-live', 'badge-cached', 'badge-error');
    el.classList.add('badge');
    if (type === 'LIVE')       { el.textContent = 'LIVE'; el.classList.add('badge-live'); }
    else if (type === 'CACHED'){ el.textContent = 'CACHED'; el.classList.add('badge-cached'); }
    else if (type === 'ERROR') { el.textContent = 'ERROR'; el.classList.add('badge-error'); }
    else                       { el.textContent = type; }
  }

  function interpolateColor(from, to, t) {
    const f = hex => parseInt(hex.replace('#',''),16);
    const [r1,g1,b1] = [(f(from)>>16)&255, (f(from)>>8)&255, f(from)&255];
    const [r2,g2,b2] = [(f(to)>>16)&255,   (f(to)>>8)&255,   f(to)&255];
    const rn = Math.round(r1 + (r2 - r1)*t);
    const gn = Math.round(g1 + (g2 - g1)*t);
    const bn = Math.round(b1 + (b2 - b1)*t);
    return `rgb(${rn},${gn},${bn})`;
  }
  function riskColor(score) {
    return score <= 50
      ? interpolateColor('#28c17d','#ffcd3c', score/50)
      : interpolateColor('#ffcd3c','#ff6f6f', (score-50)/50);
  }

  // ──────────────────────────────────────────────────────────────
  // Unified fetch + cache-fallback
  // ──────────────────────────────────────────────────────────────
  async function refreshAllWidgets() {
    let results = {};
    try {
      results = await fetch('/.netlify/functions/fetchAllData').then(r => r.json());
    } catch (e) {
      console.error('fetchAllData failed', e);
    }

    function apply(key, live, renderer) {
      const cache = cacheGet(key);
      if (live?.error) {
        if (cache?.data) {
          renderer(cache.data);
          setStatus(document.getElementById(key + '-status'), 'CACHED');
          document.getElementById(key + '-updated').textContent =
            'Updated: ' + new Date(cache.ts).toLocaleTimeString() + ' (cached)';
        } else {
          document.getElementById(key).textContent = '--';
          setStatus(document.getElementById(key + '-status'), 'ERROR');
        }
      } else if (live) {
        renderer(live);
        setStatus(document.getElementById(key + '-status'), 'LIVE');
        cacheSet(key, live);
        document.getElementById(key + '-updated').textContent =
          'Updated: ' + new Date().toLocaleTimeString();
      } else {
        document.getElementById(key).textContent = '--';
      }
    }

    // SPY
    apply('sp500', results.spy, ({ price, pct }) => {
      document.getElementById('sp500').textContent = price.toFixed(2);
      const el = document.getElementById('sp500-change');
      el.textContent = `${pct >= 0 ? '▲' : '▼'} ${Math.abs(pct).toFixed(2)}%`;
      el.className = 'change ' + (pct >= 0 ? 'up' : 'down');
    });

    // TSLA
    apply('tsla', results.tsla, ({ price, pct }) => {
      document.getElementById('tsla').textContent = price.toFixed(2);
      const el = document.getElementById('tsla-change');
      el.textContent = `${pct >= 0 ? '▲' : '▼'} ${Math.abs(pct).toFixed(2)}%`;
      el.className = 'change ' + (pct >= 0 ? 'up' : 'down');
    });

    // VIXY
    apply('vix', results.vixy, ({ price, pct }) => {
      document.getElementById('vix').textContent = price.toFixed(2);
      const el = document.getElementById('vix-change');
      el.textContent = `${pct >= 0 ? '▲' : '▼'} ${Math.abs(pct).toFixed(2)}%`;
      el.className = 'change ' + (pct >= 0 ? 'up' : 'down');
    });

    // Lithium ETF
    apply('lithium', results.lit, ({ price, pct }) => {
      document.getElementById('lithium').textContent = price.toFixed(2);
      const el = document.getElementById('lithium-change');
      el.textContent = `${pct >= 0 ? '▲' : '▼'} ${Math.abs(pct).toFixed(2)}%`;
      el.className = 'change ' + (pct >= 0 ? 'up' : 'down');
    });

    // Yield Curve
    if (results.yieldCurve?.spread != null) {
      const s = results.yieldCurve.spread, inv = results.yieldCurve.inverted;
      document.getElementById('yield').textContent = `${s.toFixed(2)}%`;
      const el = document.getElementById('yield-change');
      el.textContent = `${s >= 0 ? '▲' : '▼'} ${inv ? 'Inverted' : 'Normal'}`;
      el.className = 'change ' + (s >= 0 ? 'up' : 'down');
      setStatus(document.getElementById('yield-status'), inv ? 'INVERTED' : 'NORMAL');
      document.getElementById('yield-updated').textContent =
        'Updated: ' + new Date().toLocaleTimeString();
    }

    // Gold (FRED)
    apply('gold', results.gold, ({ price, pct }) => {
      document.getElementById('gold').textContent = price.toFixed(2);
      const el = document.getElementById('gold-change');
      if (typeof pct === 'number' && isFinite(pct)) {
        el.textContent = `${pct >= 0 ? '▲' : '▼'} ${Math.abs(pct).toFixed(2)}%`;
        el.className = 'change ' + (pct >= 0 ? 'up' : 'down');
      } else {
        el.textContent = '';
        el.className = 'change';
      }
    });

    // DXY / USD Broad Index (DTWEXBGS)
    apply('dxy', results.dxy, ({ price, pct }) => {
      document.getElementById('dxy').textContent = price.toFixed(2);
      const el = document.getElementById('dxy-change');
      if (typeof pct === 'number' && isFinite(pct)) {
        el.textContent = `${pct >= 0 ? '▲' : '▼'} ${Math.abs(pct).toFixed(2)}%`;
        el.className = 'change ' + (pct >= 0 ? 'up' : 'down');
      } else {
        el.textContent = '';
        el.className = 'change';
      }
    });

    // Guard against empty {} for Estimated Buffett
    if (results.estimatedBuffett && typeof results.estimatedBuffett.ratio === 'undefined') {
      results.estimatedBuffett = { error: 'No data' };
    }

    // Estimated Buffett
    apply('estimated-buffett', results.estimatedBuffett, ({ ratio, overvalued }) => {
      document.getElementById('estimated-buffett').textContent = `${ratio.toFixed(2)}%`;
      const el = document.getElementById('estimated-buffett-change');
      el.textContent = overvalued
        ? '▲ Overvalued'
        : (ratio >= 2.5 ? '▲ Caution' : '▼ Normal');
      el.className = 'change ' + (overvalued ? 'up' : (ratio >= 2.5 ? 'up' : 'down'));
    });

    // True Buffett
    apply('buffett', results.buffett, ({ ratio }) => {
      document.getElementById('buffett').textContent = `${ratio.toFixed(2)}%`;
      const statusEl = document.getElementById('buffett-status');
      if (ratio >= 3.0) {
        statusEl.textContent = 'ALERT';
        statusEl.classList.add('badge-error');
        statusEl.classList.remove('badge-live');
      } else {
        statusEl.textContent = 'OK';
        statusEl.classList.add('badge-live');
        statusEl.classList.remove('badge-error');
      }
    });

    // Recalc the aggregate gauge
    if (typeof refreshRiskTemperature === 'function') {
      refreshRiskTemperature();
    }
  }

  // ──────────────────────────────────────────────────────────────
  // Risk Temperature (now includes Gold & DXY)
  // ──────────────────────────────────────────────────────────────
  function refreshRiskTemperature() {
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const txt = id => (document.getElementById(id)?.textContent || '').trim();

    // helper to read "▲ 0.45%" / "▼ 0.12%" / "0.10%" into signed number
    const parseChange = (id) => {
      const t = txt(id);
      const m = t.match(/([▲▼])?\s*(-?\d+(?:\.\d+)?)%/);
      if (!m) return null;
      let v = parseFloat(m[2]);
      if (t.includes('▼')) v *= -1;
      return isFinite(v) ? v : null;
    };

    // parse values from DOM
    const vixVal = (() => {
      const v = parseFloat(txt('vix-index'));
      if (isFinite(v)) return v;
      const alt = parseFloat(txt('vix'));
      return isFinite(alt) ? alt : null;
    })();

    const ycSpread = (() => {
      const t = txt('yield').replace('%','');
      const v = parseFloat(t);
      return isFinite(v) ? v : null;
    })();

    const buffettPct = (() => {
      const t = txt('buffett').replace('%','');
      const v = parseFloat(t);
      return isFinite(v) ? v : null;
    })();

    const spyChangePct  = parseChange('sp500-change');
    const goldChangePct = parseChange('gold-change');
    const dxyChangePct  = parseChange('dxy-change');

    // component scoring (0..100)
    const vixScore = (v) => v == null ? null : clamp(((v - 12) / (35 - 12)) * 100, 0, 100);

    const ycScore = (s) => {
      if (s == null) return null;
      if (s >= 0.5) return 5;
      if (s >= 0)   return clamp((0.5 - s) / 0.5 * 50, 0, 50);
      return clamp(50 + (Math.min(0, s) / -1.0) * 50, 50, 100);
    };

    const buffettScore = (p) => p == null ? null : clamp(((p - 120) / (250 - 120)) * 100, 0, 100);

    // equities: negative return => riskier
    const spyScore = (p) => {
      if (p == null) return null;
      const scaled = 50 - (p * 10); // -5% => 100, 0% => 50, +5% => 0
      return clamp(scaled, 0, 100);
    };

    // gold: up = risk-off (higher score), down = calmer
    const goldScore = (p) => {
      if (p == null) return null;
      const scaled = 50 + (p * 10); // +5% => 100, 0% => 50, -5% => 0
      return clamp(scaled, 0, 100);
    };

    // dollar: up = risk-off (higher score), down = calmer
    const dxyScoreFn = (p) => {
      if (p == null) return null;
      const scaled = 50 + (p * 12); // +4% => ~98, 0% => 50, -4% => ~2
      return clamp(scaled, 0, 100);
    };

    const parts = [];
    const labels = [];

    const vixS = vixScore(vixVal);
    if (vixS != null) { parts.push({w: 0.30, s: vixS}); labels.push(`VIX ${vixVal.toFixed(2)}`); }

    const ycS = ycScore(ycSpread);
    if (ycS != null) { parts.push({w: 0.25, s: ycS}); labels.push(`YC ${ycSpread.toFixed(2)}%`); }

    const bufS = buffettScore(buffettPct);
    if (bufS != null) { parts.push({w: 0.20, s: bufS}); labels.push(`Buffett ${buffettPct.toFixed(0)}%`); }

    const spyS = spyScore(spyChangePct);
    if (spyS != null) { parts.push({w: 0.10, s: spyS}); labels.push(`S&P ${spyChangePct>=0?'+':''}${spyChangePct?.toFixed(2)}%`); }

    const gS = goldScore(goldChangePct);
    if (gS != null) { parts.push({w: 0.075, s: gS}); labels.push(`Gold ${goldChangePct>=0?'+':''}${goldChangePct?.toFixed(2)}%`); }

    const dS = dxyScoreFn(dxyChangePct);
    if (dS != null) { parts.push({w: 0.075, s: dS}); labels.push(`DXY ${dxyChangePct>=0?'+':''}${dxyChangePct?.toFixed(2)}%`); }

    if (parts.length === 0) {
      const scoreEl = document.getElementById('risk-temp-score');
      const statusEl = document.getElementById('risk-temp-status');
      const detailsEl = document.getElementById('risk-temp-details');
      const updEl = document.getElementById('risk-temp-updated');
      if (scoreEl) scoreEl.textContent = '--%';
      if (statusEl) statusEl.textContent = '--';
      if (detailsEl) detailsEl.textContent = 'Waiting for signals…';
      if (updEl) updEl.textContent = 'Updated: ' + new Date().toLocaleTimeString();
      return;
    }

    const wsum = parts.reduce((a, b) => a + b.w, 0);
    const score = parts.reduce((a, b) => a + b.s * (b.w / wsum), 0);
    const scorePct = Math.round(score);

    let bucket = 'Calm';
    if (scorePct >= 75) bucket = 'Alert';
    else if (scorePct >= 50) bucket = 'Watch';
    else if (scorePct >= 25) bucket = 'Elevated';

    const scoreEl = document.getElementById('risk-temp-score');
    const statusEl = document.getElementById('risk-temp-status');
    const needleEl = document.getElementById('risk-temp-needle');
    const markerEl = document.getElementById('risk-temp-marker');
    const detailsEl = document.getElementById('risk-temp-details');
    const updEl = document.getElementById('risk-temp-updated');

    if (scoreEl) scoreEl.textContent = `${scorePct}%`;
    if (statusEl) {
      statusEl.textContent = bucket;
      statusEl.style.background = 'none';
      statusEl.style.color = riskColor(scorePct);
    }
    if (needleEl) needleEl.style.left = `${scorePct}%`;
    if (markerEl) markerEl.style.left = `${scorePct}%`;
    if (detailsEl) detailsEl.textContent = labels.join(' · ');
    if (updEl) updEl.textContent = 'Updated: ' + new Date().toLocaleTimeString();
  }

  // ──────────────────────────────────────────────────────────────
  // VIX Index (^VIX) — fetch direct from function and render
  // ──────────────────────────────────────────────────────────────
  async function refreshVIXIndex() {
    const spinner = document.getElementById('vix-index-spinner');
    if (spinner) spinner.style.display = 'inline-block';

    try {
      const res = await fetch('/.netlify/functions/vixIndex?bust=' + Date.now());
      if (!res.ok) throw new Error('HTTP ' + res.status);
      const json = await res.json();
      if (json.error) throw new Error(json.error);

      const price = Number(json.price);
      const change = (json.changePercent == null || isNaN(Number(json.changePercent)))
        ? null : Number(json.changePercent);
      if (!Number.isFinite(price)) throw new Error('Bad price from vixIndex');

      const valEl = document.getElementById('vix-index');
      if (valEl) valEl.textContent = price.toFixed(2);

      const changeEl = document.getElementById('vix-index-change');
      if (changeEl) {
        if (typeof change === 'number') {
          changeEl.textContent = `${change >= 0 ? '▲' : '▼'} ${Math.abs(change).toFixed(2)}%`;
          changeEl.className = 'change ' + (change >= 0 ? 'up' : 'down');
        } else {
          changeEl.textContent = '';
          changeEl.className = 'change';
        }
      }

      const tsEl = document.getElementById('vix-index-updated');
      if (tsEl) tsEl.textContent = 'Updated: ' + new Date().toLocaleTimeString();

      setStatus(document.getElementById('vix-index-status'), 'LIVE');

      // cache it
      cacheSet('vix-index', { price, change });
    } catch (e) {
      console.error('VIX Index error', e);
      const c = cacheGet('vix-index');
      if (c?.data) {
        const { price, change } = c.data;
        const valEl = document.getElementById('vix-index');
        if (valEl) valEl.textContent = Number(price).toFixed(2);

        const changeEl = document.getElementById('vix-index-change');
        if (changeEl && typeof change === 'number') {
          changeEl.textContent = `${change >= 0 ? '▲' : '▼'} ${Math.abs(change).toFixed(2)}%`;
          changeEl.className = 'change ' + (change >= 0 ? 'up' : 'down');
        } else if (changeEl) {
          changeEl.textContent = '';
          changeEl.className = 'change';
        }

        const tsEl = document.getElementById('vix-index-updated');
        if (tsEl) tsEl.textContent = 'Updated: ' + new Date(c.ts).toLocaleTimeString() + ' (cached)';

        setStatus(document.getElementById('vix-index-status'), 'CACHED');
      } else {
        const valEl = document.getElementById('vix-index');
        if (valEl) valEl.textContent = 'Error';
        setStatus(document.getElementById('vix-index-status'), 'ERROR');
      }
    } finally {
      if (spinner) spinner.style.display = 'none';
      if (typeof refreshRiskTemperature === 'function') refreshRiskTemperature();
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    refreshAllWidgets();
    refreshVIXIndex();
    setInterval(refreshAllWidgets, 120000);
    setInterval(refreshVIXIndex, 120000);
  });
</script>
